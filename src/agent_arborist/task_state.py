"""Task tree data structures for DAG building.

These are used only at DAG build time, not for runtime state tracking.
Runtime state is tracked by jj descriptions and DAGU execution.
"""

from dataclasses import dataclass, field
from typing import Literal


TaskStatus = Literal["pending", "running", "complete", "failed"]


@dataclass
class TaskNode:
    """A task in the hierarchy.

    Used for building DAGs - not for runtime state tracking.
    """

    task_id: str
    description: str
    status: TaskStatus = "pending"
    parent_id: str | None = None
    children: list[str] = field(default_factory=list)
    depends_on: list[str] = field(default_factory=list)  # Sequential dependencies (phases)
    branch: str | None = None
    worktree: str | None = None
    error: str | None = None


@dataclass
class TaskTree:
    """Complete task hierarchy for a spec.

    Used for building DAGs - not for runtime state tracking.
    """

    spec_id: str
    tasks: dict[str, TaskNode] = field(default_factory=dict)
    root_tasks: list[str] = field(default_factory=list)

    def get_task(self, task_id: str) -> TaskNode | None:
        """Get a task by ID."""
        return self.tasks.get(task_id)

    def get_parent(self, task_id: str) -> TaskNode | None:
        """Get parent task."""
        task = self.tasks.get(task_id)
        if task and task.parent_id:
            return self.tasks.get(task.parent_id)
        return None

    def get_children(self, task_id: str) -> list[TaskNode]:
        """Get child tasks."""
        task = self.tasks.get(task_id)
        if task:
            return [self.tasks[cid] for cid in task.children if cid in self.tasks]
        return []

    def is_leaf(self, task_id: str) -> bool:
        """Check if task has no children."""
        task = self.tasks.get(task_id)
        return task is not None and len(task.children) == 0


def build_task_tree_from_yaml(spec_id: str, yaml_content: str) -> TaskTree:
    """Build task tree from generated DAG YAML.

    Extracts task IDs and parent-child relationships from the multi-document
    YAML that was generated by AI or the deterministic builder.

    This is the preferred method as it ensures the manifest matches
    what was actually generated in the DAG.
    """
    import yaml
    import re

    tree = TaskTree(spec_id=spec_id)
    documents = list(yaml.safe_load_all(yaml_content))

    if not documents:
        return tree

    # First document is root DAG, rest are subdags (one per task)
    root_dag = documents[0]
    subdags = documents[1:] if len(documents) > 1 else []

    # Extract task IDs from subdags - each subdag name is a task ID
    task_ids = set()
    subdag_calls: dict[str, list[str]] = {}  # task_id -> list of child task_ids it calls

    for subdag in subdags:
        task_id = subdag.get("name", "")
        if not task_id or not re.match(r"T\d+", task_id):
            continue

        task_ids.add(task_id)

        # Find what other tasks this subdag calls
        calls = []
        for step in subdag.get("steps", []):
            call_target = step.get("call")
            if call_target and re.match(r"T\d+", call_target):
                calls.append(call_target)
        subdag_calls[task_id] = calls

    # Also check root dag for direct task calls (flat structure)
    root_calls = []
    for step in root_dag.get("steps", []):
        call_target = step.get("call")
        if call_target and re.match(r"T\d+", call_target):
            task_ids.add(call_target)
            root_calls.append(call_target)

    # Create task nodes
    for task_id in sorted(task_ids):
        tree.tasks[task_id] = TaskNode(
            task_id=task_id,
            description=task_id,  # We don't have description from YAML
        )

    # Build parent-child relationships from calls
    # If task A calls task B, then B is a child of A
    for parent_id, children in subdag_calls.items():
        if parent_id not in tree.tasks:
            continue
        for child_id in children:
            if child_id in tree.tasks:
                tree.tasks[child_id].parent_id = parent_id
                if child_id not in tree.tasks[parent_id].children:
                    tree.tasks[parent_id].children.append(child_id)

    # Find root tasks (no parent, or called directly from root dag)
    tree.root_tasks = [
        tid for tid, task in tree.tasks.items()
        if task.parent_id is None
    ]

    return tree
